# CS 241e
## Foundations of Sequential Programs Enriched

Prof. Ondr̂ej Lhoták


# 1. Introduction
## Bits
- Have no assigned meaning by themselves

### Conventions
There are infinitely many integers, but only 2<sup>32</sup> can be represented on a 32-bit system, so arithmetic is done on the finite ring of equivalence classes mod 2<sup>32</sup>.

### Numeric Interpretation
- As an unsigned integer, there are 2<sup>32-1</sup> integers in a 32-bit int
- In Two's Complement signed integers, the first bit is the sign bit
  - Addition, multiplication, and subtraction are the same as om  integers
  - Division and magnitude comparison need separate operations for unsigned and Two's Complement numbers

## Our Computer
The computer we're using happens to have state equivalent to {0, 1}<sup>2<sup>26</sup> + 32 * 34</sup>

```
+------------------------------------------------+          Memory
|                                                |            32
|                            Registers           |    0 +-----------+
|   +-----------------+          32              |    4 |           |
|   |   Control Unit  |    +---------------+     |    8 |           |
|   |                 |   1| 0 1 0 ...     |     |    12|           |
|   +-----------------+   2| 1             |     | ->   |           |
|   |       ALU       |   .| 0             |     |      |           |
|   |                 |   .|               |34   |      |           |
|   |                 |  31|               |     |    . |           |
|   |                 |  LO|               |     |    . |           |
|   |                 |  HI|               |     |    . |           |
|   +-----------------+  PC+---------------+     |      |           |
|                                                |      +-----------+
+------------------------------------------------+   2^24-4
```
PC = program counter (the register we're on)

The CPU implements a function `step`:
```
step: state -> state
s_(i+1) = step(s_i)
Def: step*(s) = if (step(s) defined) step*(step(s)) else s

input
  | encode
  v       step*
  s_0 -----------> s_n

Want:
For all i, f(i) = decode(step*(encode(i)))

(program, input)           (program, data)      
       |                         ^
       | encode (compiler)       | decode
       |                         |
       v         step*           |
       s_0 -------------------> s_n
```

### Definitions
A **stored program computer (von Neumann machine)** includes the program as part of its input
- `step` should be general
  - `sem*(program, input) = decode( step*( encode(program, input) ) )`
  - `sem ((lambda (x) e) v)`
    - `[x |-> v] e`
    - `x` gets sustituted with `v` in `e`

**Semantics**: meaning of a program
- **operational semantics**: semantics defined in terms of a function that transforms state
  - an interpreter, basically

### Defining step functions
```scala
def step(state) = {

  // fetch
  instruction = state.memory[state.register[PC]]

  // increment PC
  state2 = state.setRegister(PC, state.register(PC)+4)

  // decode, execute
  instruction.match {
    // ...
  }
}
```

## MIPS
Reference: https://www.student.cs.uwaterloo.ca/~cs241/mips/mipsref.pdf
- When a word is stored to memory location 0xffff000c, the least-significant byte (eight bits) of the word are sent to the standard output.
- Loading a word from memory location 0xffff0004 places the next byte from standard input into the least-significant byte of the destination register.

An **opcode** is a short name for a machine language instruction
**Assembly language** is a language for writing machine language programs with opcodes
An **assembler** is a program that translates assembly language to machine language

# Compiler features
## Labels
An abstraction of memory addresses

e.g.: absolute value
```assembly
SLT 2, 1, 0
BEQ 2, 0, 1
SUB 1, 0, 1
JR 31
```

Same example, using labels:
```assembly
SLT 2, 1, 0
BEQ 2, 0, label
SUB 1, 0, 1
Define label
JR 31
```

e.g. a procedure
```assembly
... ; main
... ; program
LIS 1
USE label
JALR 1
...

DEFINE label
... ; procedure
...
...
JR
```

To compile out labels, we need two passes:
1. Determine the address of each label
2. Generate code for all the instructions with labels converted to their corresponding addresses

### Relocation, Linking
An **object file** is a file that contains:
- machine language code
- metadata recording how labels were used before the translation to machine language

**Relocation** is the process of adjusting machine language code using object file metatada so that it can be loaded at a different address by:
- reverse-engineering labels
- reassembling at a new address

**Linking** is the process of combining multiple object files into a machine code program
- To link assembly language files, just concatenate them together
- To link object files:
  - reverse-engineer the labels from the metadata
  - relocation, label resolution across different files
  - concatenate assembly language programs
  - reassemble them to machine language

Typical C build process:
```
C source              Assembly        Object
files              files           files
a.c -----------> a.s -----------> a.o ---+
   Compiler (cc)    Assembler (as)       |
                                         |
b.c -----------> b.s -----------> b.o ---+--> linker (ld) ------> executable machine language program
                                         |
                                         |
c.c -----------> c.s -----------> c.o ---+
```

## Variables
A **variable** is an abstraction of a storage location (register, *fixed* or *dynamically determined* address in memory) that can hold a value

Read from address ALPHA to $1:
```assembly
LIS 2
WORD ALPHA ; Saves address ALPHA into register 2
LW 1, 0, 2 ; Loads value from memory address ALPHA into register 1
```

### Variable instances
e.g.
```scala
def fact(x: Int): Int = if (x < 2) 1 else x*fact(x-1)
fact(3)
// fact(3) = 3 * fact(2) = 3 * 2 * fact(1) = 3*2*1 = 6
// Three instances of x occur in this execution
```

```
               fact(1)
               +--------+
       fact(2) |        |
       +-------+        +-------+
fact(3)|                        |
-------+                        +--------
                 time -->
```

The **extent** of a variable instance is the time interval in which it can be accessed
e.g.
procedure-level variable: execution of procedure
global variable: entire execution of program
field of object/record: from he time that object is allocated to time it is deallocated/freed (explicitly or automatically with GC)

### The Stack
The extent of local variables begin and end in a **last in, first out** order. A **stack** allows us to create and destroy storage locations this way.

#### Implementation
- Designate a variable (register, usually; R30 in this course) to hold the address at the top of the stack (the **stack pointer**)
- To push to stack: decrement stack pointer by 4
- To pop from stack: increment stack pointer by 4

After entering a procedure with variables a, b, c
```
                  memory
               +-----------+
               |           |
               +-----------+
               |    42     |
               +-----------+
      SP = 100 |     a     | \
               +-----------+ |
           104 |     b     | | stack frame (all local
               +-----------+ | vars from procedure)
           108 |     c     | /
               +-----------+
           112 |   stack   |
               +-----------+
```

e.g. read variable c at offset 8 from SP
```assembly
LWC 1, 8, 30 ; 8, 30 = offset, register
```

**Symbol table**: a map from variables to offsets
**Frame pointer**: a copy of the stack pointer that stays fixed for the duration of a procedure call. It enables us to use the stack for other purposes within the procedure
Convention: use R30 for stack pointer, R29 for frame pointer; bottom of stack is at the end of memory

In this course, all data in memory will be in **chunks**
- areas of consecutive memory locations
- indexed by variables (symbol table)
- base register
- can generate code to read/write variables

## Evaluating expressions
e.g. `a*b + c*d`

### Technique 1 (stack)
```
t1 = a*b
t2 = c*d
t3 = t1+t2
```

```scala
def evaluate(e1, op, e2): Code = {
  evaluate(e1)
  push $3
  evaluate(e2)
  pop $4
  $3 = $4 op $3
}
def evaluateVar(v: Variable): Code = read v (into $3)
```
- general
- inefficient
- difficult to transform further

### Technique 2 (temporary variables)
```
t1 = a*b
t2 = c*d    // generate code to eval e1 op e2, put result in some variable
t3 = t1+t2  // return code, variable
```

```scala
def evaluate(e1, op, e2): (Code, Variable) = {
  (code1, var1) = evaluate(e1)
  (code2, var2) = evaluate(e2)
  v3 = new Variable
  code = block(code1, code2, var3 = var1 op var2)
  return (code, var3)
}
```
- flexible, easy to transform
- machine language operations require registers, so many variables means inefficient use of memory/registers
**Register allocation** isi the process of assigning variables to real registers or memory addresses (abstract)
Minimize the number of registers/memory locations used by **sharing them** amongn non-interfering variables.
```
+------------------+                 +----------------+
|       Code       |                 | IR with real   |
|Intermediate      |---------------->| registers      |
|Representation    |  register       | addresses/     |
|with virtual regs |  allocation     | offsets        |
+------------------+                 +----------------+
```

### Technique 3 (hybrid) (temp vars, but operations on real registers)

```
t1 = a*b  // $4 = a, $3 = b, $3 = $4 * $3, t1 = $3
t2 = c*d
t3 = t1+t2
```
```scala
// generated code leaves result in $3
def evaluate(e1 op e2):Code = {
  val t1 = new Variable
  block(
    evaluate(e1),
    write(e1, 3),
    evaluate(e2),
    read(4, t1),
    $3 = $4 op $3
  )
}
```

### Register allocation
e.g. a+b+c+d+e
A variable is **live at program point p** if the value that it holds at p may be read sometime after p.
The **live range** of a variable is the set of program points where it is live.
- The start of a live range is always just after a write
- The end of a live range is always just after a read
Two variables can share the same register iff their live ranges do not intersect.

#### e.g.
t1 = a * b
- t1 live
t2 = c * d
- t1, t2 live
t3 = t1 * t2
- t3 live
e = t3


#### e.g.
e.g.
t1 = a * b
- t1 live
t2 = c * d
- t1, t2
t3 = t1 + t2
- t3
t4 = e * f
- t3, t4
t5 = t3 - t4
- t3, t5
g = t3 + t5

reg1: t1, t3
reg2: t2, t4, t5

r1 = a * b
r2 = c * d
r1 = r1 + r2
r2 = e * f
r2 = r1 - r2
g = r1 + r2

## Interference graph
- Vertices are variables
- Edge from (v1 - v2) if v1 and v2 conflict (both live at the same program point)
- A **colouring** assigns a colour to each vertex so that every edge connects vertices of distinct colours
  - each colour corresponds to a register, so colouring is a register assignment
  - Finding a minimal colouring of an arbitrary graph is NP-hard.
- A simple greedy algorithm (not optimal):
  - For each vertex v, colour v with the smallest colour not yet used by its neighbours
- Many graphs (SSA form interference graphs) have special structure that enables efficient algorithms


## Control structures
If statements
```scala
if (e1, op, e2, then, else) => {
  withTempVar{t1 =>
    evaluate(e1)
    t1 = $3
    evaluate(e2)
    $4 = t1
    evaluate op
    T
    beq
    define(else)
    E
    define(end)
  }
}
```

Procedures: an abstraction that encapsulates a reusable sequence of code
- calling code and procedure agree on conventions
  - ehere (memory/registers) to pass arguments and return value
  - which registers procedures may modify (caller-save) or preserve (callee-save)
- calling code **transfers control** to the procedure (modifies PC)
- calling code passes arguments for parameters
- procedure transfers controle back to caller
- returns a value

### e.g.
Caller | Procedure (callee)
---------------------------
 | `Define(proc)`
 | `Reg.savedParamPtr = Reg.allocated`
 | `stack.allocate(frame)`
evaluate args in temp vars |
`Stack.allocate(parameters)` | 
copy arguments from temp vars into parameter chunk |
 | `dynamicLink = Reg.fp` (29)
 | `savedPC = Reg.savedPC` (31)
 | `Reg.fp = Reg.allocated` (6)
 | `paramPtr = Reg.savedParamPtr` (get it out of a register)
`LIS(Reg.targetPC)` | `body`
`Use(proc)` | 
`JALR(Reg.targetPC)` | `Reg.savedPC = savedPC`
 | `Reg.fp = dynamicLink`
 | `stack.pop //frame`
 | `stack.pop //parameters`
 | `JR(31)`

### Conventions:
Modifies: 31, 6, 5, all others
Preserves: 30 (sp), 29 (fp)
- Caller allocates chunk for arguments
  - puts address in Reg.allocated
- Callee allocates and frees chunk for variables

## Eliminating variable accesses (A5)
- If v is a variable (including a temp var) of the procedure:
  - Access v in the frame chunk (A3)
- Otherwise, v is a parameter:
  - read param pointer from normal chunk into Reg.scratch (4)
  - access v in parameter chunk (with base register Reg.scratch that param ptr was read into)

A **dynamic link** is a pointer to the frame of the procedure that called the currently executing procedure.
A **prologue/epilogue** are the instructions at the beginning or end of a procedure
